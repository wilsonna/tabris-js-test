/*!
 * tabris.js 2015-02-27
 * 
 * Copyright (c) 2014, 2015 EclipseSource Inc.
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 * * Redistributions of source code must retain the above copyright notice, this
 *   list of conditions and the following disclaimer.
 * 
 * * Redistributions in binary form must reproduce the above copyright notice,
 *   this list of conditions and the following disclaimer in the documentation
 *   and/or other materials provided with the distribution.
 * 
 * * Neither the name of Tabris.js nor the names of its
 *   contributors may be used to endorse or promote products derived from
 *   this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
(function(){
/* jshint unused: false */
var util = {

  extend: function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var name in source) {
        target[name] = source[name];
      }
    }
    return target;
  },

  pick: function(object, keys) {
    var result = {};
    for (var key in object) {
      if (keys.indexOf(key) !== -1) {
        result[key] = object[key];
      }
    }
    return result;
  },

  omit: function(object, keys) {
    var result = {};
    for (var key in object) {
      if (keys.indexOf(key) === -1) {
        result[key] = object[key];
      }
    }
    return result;
  },

  clone: function(object) {
    var result = {};
    for (var key in object) {
      result[key] = object[key];
    }
    return result;
  },

  rename: function(object, mapping) {
    var result = {};
    for (var key in object) {
      result[mapping[key] || key] = object[key];
    }
    return result;
  },

  invert: function(object) {
    var result = {};
    for (var key in object) {
      result[object[key]] = key;
    }
    return result;
  },

  bind: function(fn, context) {
    return function() {
      return fn.apply(context, arguments);
    };
  },

  extendPrototype: function(fn, target) {
    var Helper = function() {};
    Helper.prototype = fn.prototype;
    return this.extend(new Helper(), target, {
      "super": function(method) {
        return fn.prototype[ method ].apply(this, Array.prototype.slice.call(arguments, 1));
      }
    });
  }

};

(function() {

  util.colorArrayToString = function(array) {
    var r = array[0];
    var g = array[1];
    var b = array[2];
    var a = array.length === 3 ? 1 : Math.round(array[3] * 100 / 255) / 100;
    return "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
  };

  util.colorStringToArray = function(str) {
    if (str === "transparent") {
      return [0, 0, 0, 0];
    }
    // #xxxxxx
    if (/^#([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/.test(str)) {
      return [
        parseInt(RegExp.$1, 16),
        parseInt(RegExp.$2, 16),
        parseInt(RegExp.$3, 16),
        255
      ];
    }
    // #xxx
    if (/^#([0-9a-fA-F])([0-9a-fA-F])([0-9a-fA-F])$/.test(str)) {
      return [
        parseInt(RegExp.$1, 16) * 17,
        parseInt(RegExp.$2, 16) * 17,
        parseInt(RegExp.$3, 16) * 17,
        255
      ];
    }
    // #rgb(r, g, b)
    if (/^rgb\s*\(\s*([+\-]?[0-9]+)\s*,\s*([+\-]?[0-9]+)\s*,\s*([+\-]?[0-9]+)\s*\)$/.test(str)) {
      return [
        Math.max(0, Math.min(255, parseInt(RegExp.$1))),
        Math.max(0, Math.min(255, parseInt(RegExp.$2))),
        Math.max(0, Math.min(255, parseInt(RegExp.$3))),
        255
      ];
    }
    // rgba(r, g, b, a)
    if (/^rgba\s*\(\s*([+\-]?[0-9]+)\s*,\s*([+\-]?[0-9]+)\s*,\s*([+\-]?[0-9]+)\s*,\s*([+\-]?([0-9]*\.)?[0-9]+)\s*\)$/.test(str)) {
      return [
        Math.max(0, Math.min(255, parseInt(RegExp.$1))),
        Math.max(0, Math.min(255, parseInt(RegExp.$2))),
        Math.max(0, Math.min(255, parseInt(RegExp.$3))),
        Math.round(Math.max(0, Math.min(1, parseFloat(RegExp.$4))) * 255)
      ];
    }
    // named colors
    if (str in NAMES) {
      var rgb = NAMES[str];
      return [rgb[0], rgb[1], rgb[2], 255];
    }
    throw new Error("invalid color: " + str);
  };

  /*
   * Basic color keywords as defined in CSS 3
   * See http://www.w3.org/TR/css3-color/#html4
   */
  var NAMES = {
    black: [0, 0, 0],
    silver: [192, 192, 192],
    gray: [128, 128, 128],
    white: [255, 255, 255],
    maroon: [128, 0, 0],
    red: [255, 0, 0],
    purple: [128, 0, 128],
    fuchsia: [255, 0, 255],
    green: [0, 128, 0],
    lime: [0, 255, 0],
    olive: [128, 128, 0],
    yellow: [255, 255, 0],
    navy: [0, 0, 128],
    blue: [0, 0, 255],
    teal: [0, 128, 128],
    aqua: [0, 255, 255]
  };

})();

(function() {

  util.fontStringToArray = function(str) {
    var result = [[], 0, false, false];
    var parts = str.split(/(?:\s|^)\d+px(?:\s|$)/);
    checkTruthy(parts.length === 2 || parts.length === 1, "Invalid font syntax");
    result[1] = parseInt(/(?:\s|^)(\d+)px(?:\s|$)/.exec(str)[1], 10);
    parseStyles(result, parts[0]);
    parseFamily(result, parts[1]);
    return result;
  };

  util.fontArrayToString = function(fontArr) {
    return (fontArr[3] ? "italic " : "") + (fontArr[2] ? "bold " : "") +
        (fontArr[1] + "px") + (fontArr[0][0] ? " " : "") + (fontArr[0].join(", "));
  };

  var parseStyles = function(fontArr, styles) {
    var styleArr = styles.trim().split(/\s+/);
    checkTruthy(styleArr.length <= 2, "Too many font styles");
    styleArr.forEach(function(property) {
      switch (property.trim()) {
        case "italic":
          checkTruthy(fontArr[3] === false, "Invalid font variant");
          fontArr[3] = true;
          break;
        case "bold":
          checkTruthy(fontArr[2] === false, "Invalid font weight");
          fontArr[2] = true;
          break;
        case "normal":
        case "":
          break;
        default:
          throw new Error("Unknown font property: " + property.trim());
      }
    });
  };

  var parseFamily = function(fontArr, family) {
    // NOTE: Currently family is optional to allow for default fonts, but this is
    //       not CSS font syntax. See https://github.com/eclipsesource/tabris-js/issues/24
    (family ? family.split(",") : []).forEach(function(name) {
      var valid = /(?:^\s*[^\"\']+\s*$)|(?:^\s*\"[^\"\']+\"\s*$)|(?:^\s*\'[^\"\']+\'\s*$)/.exec(name);
      checkTruthy(valid, "Invalid font family: " + name);
      fontArr[0].push(/^\s*[\"\']?([^\"\']*)/.exec(name)[1].trim());
    });
  };

  var checkTruthy = function(value, message) {
    if (!value) {
      throw new Error(message);
    }
  };

}());

(function() {

  util.imageToArray = function(value) {
    return [value.src, checkValue(value.width), checkValue(value.height), checkValue(value.scale)];
  };

  util.imageFromArray = function(value) {
    var result = {src: value[0]};
    if (value.length > 1) {
      result.width = value[1];
    }
    if (value.length > 2) {
      result.height = value[2];
    }
    if (value.length > 3) {
      result.scale = value[3];
    }
    return result;
  };

  function checkValue(value) {
    return value != null ? value : null;
  }

}());

(function(module) {

  window.tabris = module.exports = util.extend(function(id) {
    if (!tabris._proxies[id] && !tabris[id]) {
      throw new Error("No native object with id or type " + id);
    }
    var nativeId = tabris[id] && tabris[id]._type ? tabris[id]._type : id;
    return nativeId in tabris._proxies ? tabris._proxies[nativeId] : new tabris[id](nativeId);
  }, {

    _loadFunctions: [],
    _proxies: {},
    _ready: false,

    load: function(fn) {
      if (tabris._ready) {
        fn.call();
      } else {
        tabris._loadFunctions.push(fn);
      }
    },

    create: function(type, properties) {
      if (!tabris._nativeBridge) {
        throw new Error("tabris.js not started");
      }
      if (!(type in tabris)) {
        throw new Error("Unknown type " + type);
      }
      if (tabris[type].prototype.type !== type) {
        console.warn("\"" + type + "\" is deprecated, use \"" + tabris[type].prototype.type + "\"");
      }
      return new tabris[type]()._create(properties || {});
    },

    registerType: function(type, members) {
      if (type in tabris) {
        throw new Error("Type already registered: " + type);
      }
      tabris[type] = function() {
        tabris.Proxy.apply(this, arguments);
      };
      if (members._listen && !members._events) {
        // TODO: This can be removed once cordova is fixed
        members._events = members._listen;
        delete members._listen;
      }
      for (var member in staticMembers) {
        tabris[type][member] = members[member] || getDefault(member);
      }
      tabris[type]._events = normalizeEventsMap(tabris[type]._events);
      tabris[type]._trigger = buildTriggerMap(tabris[type]._events);
      var superProto = util.omit(members, Object.keys(staticMembers));
      superProto.type = type;
      superProto.constructor = tabris[type]; // util.extendPrototype can not provide the original
      tabris[type].prototype = util.extendPrototype(tabris.Proxy, superProto);
    },

    version: "0.9.2",

    _init: function(client) {
      tabris.off();
      tabris._client = client;
      tabris._nativeBridge = new tabris.NativeBridge(client);
      var i = 0;
      while (i < tabris._loadFunctions.length) {
        tabris._loadFunctions[i++].call();
      }
      tabris._ready = true;
    },

    _setEntryPoint: function(entryPoint) {
      this._entryPoint = entryPoint;
    },

    _notify: function(id, event, param) {
      try {
        var proxy = tabris._proxies[id];
        if (proxy) {
          try {
            proxy._trigger(event, param);
          } catch (error) {
            console.error(error);
            console.log(error.stack);
          }
        }
        tabris.trigger("flush");
      } catch (ex) {
        console.error(ex);
        console.log(ex.stack);
      }
    },

    _reset: function() {
      this._loadFunctions = [];
      this._proxies = {};
    }

  });

  function normalizeEventsMap(events) {
    var result = {};
    for (var event in events) {
      var entry = events[event];
      result[event] = typeof entry === "object" ? entry : {};
      if (!result[event].name) {
        result[event].name = typeof entry === "string" ? entry : event;
      }
    }
    return result;
  }

  function buildTriggerMap(events) {
    var result = {};
    for (var event in events) {
      var name = events[event].name;
      result[name] = event;
    }
    return result;
  }

  function getDefault(member) {
    var value = staticMembers[member];
    return value instanceof Object ? util.clone(value) : value;
  }

  var staticMembers = {
    "_events": {},
    "_initProperties": {},
    "_type": null,
    "_properties": {},
    "_supportsChildren": false
  };

}(typeof module !== "undefined" ? module : {}));

(function() {

  tabris.NativeBridge = function(bridge) {
    this._bridge = bridge;
    this._operations = [];
    this._currentOperation = {id: null};
    tabris.on("flush", this.flush, this);
  };

  tabris.NativeBridge.prototype = {

    create: function(id, type) {
      var properties = {};
      this._operations.push(["create", id, type, properties]);
      this._currentOperation = {id: id, properties: properties};
    },

    set: function(id, name, value) {
      if (this._currentOperation.id === id) {
        this._currentOperation.properties[name] = value;
      } else {
        var properties = {};
        properties[name] = value;
        this._operations.push(["set", id, properties]);
        this._currentOperation = {id: id, properties: properties};
      }
    },

    listen: function(id, event, listen) {
      this._operations.push(["listen", id, event, listen]);
      this._currentOperation = {id: null};
    },

    destroy: function(id) {
      this._operations.push(["destroy", id]);
      this._currentOperation = {id: null};
    },

    get: function(id, name) {
      this.flush();
      return this._bridge.get(id, name);
    },

    call: function(id, method, parameters) {
      this.flush();
      return this._bridge.call(id, method, parameters);
    },

    flush: function() {
      tabris.trigger("beforeFlush");
      var operations = this._operations;
      this._operations = [];
      this._currentOperation = {id: null};
      var length = operations.length;
      // Using apply() on the native bridge does not work with Rhino. It seems that the parameter
      // count must be known in order to find the associated native method.
      for (var i = 0; i < length; i++) {
        var op = operations[i];
        switch (op[0]) {
          case "create":
            this._bridge.create(op[1], op[2], op[3]);
            break;
          case "set":
            this._bridge.set(op[1], op[2]);
            break;
          case "listen":
            this._bridge.listen(op[1], op[2], op[3]);
            break;
          case "destroy":
            this._bridge.destroy(op[1]);
        }
      }
    }
  };

})();

tabris.Events = {

  on: function(type, callback, context) {
    this._checkDisposed();
    var wasListening = this._isListening(type);
    if (!this._callbacks) {
      this._callbacks = [];
    }
    this._callbacks[type] = (this._callbacks[type] || []).concat([
      {
        fn: callback,
        ctx: context
      }
    ]);
    if (!wasListening) {
      this._listen(type, true);
    }
    return this;
  },

  off: function(type, callback, context) {
    this._checkDisposed();
    if (this._callbacks) {
      if (!type) {
        delete this._callbacks;
      } else if (type in this._callbacks) {
        if (!callback) {
          delete this._callbacks[type];
        } else {
          var callbacks = this._callbacks[type].concat();
          for (var i = callbacks.length - 1; i >= 0; i--) {
            if ((callbacks[i].fn === callback || callbacks[i].fn._callback === callback) &&
              (!context || callbacks[i].ctx === context)) {
              callbacks.splice(i, 1);
            }
          }
          if (callbacks.length === 0) {
            delete this._callbacks[type];
            if (Object.keys(this._callbacks).length === 0) {
              delete this._callbacks;
            }
          } else {
            this._callbacks[type] = callbacks;
          }
        }
      }
    }
    if (!this._isListening(type)) {
      this._listen(type, false);
    }
    return this;
  },

  once: function(type, callback, context) {
    this._checkDisposed();
    var self = this;
    var wrappedCallback = function() {
      self.off(type, wrappedCallback, context);
      callback.apply(this, arguments);
    };
    wrappedCallback._callback = callback;
    return this.on(type, wrappedCallback, context);
  },

  trigger: function(type /*, args* */) {
    this._checkDisposed();
    if (this._callbacks && type in this._callbacks) {
      var callbacks = this._callbacks[type];
      var args = Array.prototype.slice.call(arguments, 1);
      for (var i = 0; i < callbacks.length; i++) {
        var callback = callbacks[i];
        callback.fn.apply(callback.ctx || this, args);
      }
    }
    return this;
  },

  _isListening: function(type) {
    return !!this._callbacks && (!type || type in this._callbacks);
  },

  _checkDisposed: function() {},
  _listen: function() {}

};

util.extend(tabris, tabris.Events);

(function() {

  tabris.Layout = {

    checkLayoutData: function(layoutData) {
      if ("centerX" in layoutData) {
        if (("left" in layoutData) || ("right" in layoutData)) {
          console.warn("Inconsistent layoutData: centerX overrides left and right");
          return util.omit(layoutData, ["left", "right"]);
        }
      } else if (!("left" in layoutData) && !("right" in layoutData)) {
        console.warn("Incomplete layoutData: either left, right or centerX should be specified");
      }
      if ("baseline" in layoutData) {
        if (("top" in layoutData) || ("bottom" in layoutData) || ("centerY" in layoutData)) {
          console.warn("Inconsistent layoutData: baseline overrides top, bottom, and centerY");
          return util.omit(layoutData, ["top", "bottom", "centerY"]);
        }
      } else if ("centerY" in layoutData) {
        if (("top" in layoutData) || ("bottom" in layoutData)) {
          console.warn("Inconsistent layoutData: centerY overrides top and bottom");
          return util.omit(layoutData, ["top", "bottom"]);
        }
      } else if (!("top" in layoutData) && !("bottom" in layoutData)) {
        console.warn("Incomplete layoutData: either top, bottom, centerY, or baseline should be specified");
      }
      return layoutData;
    },

    encodeLayoutData: function(layoutData, targetWidget, force) {
      if (!targetWidget) {
        return layoutData;
      }
      var result = {};
      var parent = targetWidget.parent() || emptyParent;
      for (var key in layoutData) {
        result[key] = encodePart(layoutData[key], key, parent, force);
      }
      return result;
    }

  };

  function encodePart(part, name, parent, force) {
    if (typeof part === "number") {
      return part;
    }
    if (Array.isArray(part)) {
      return encodeArrayPart(part, name, parent, force);
    }
    if (isPercentage(part)) {
      return [parseInt(part), 0];
    }
    if (!directWidgetRef[name]) {
      return [toProxyId(part, parent, force), 0];
    }
    return toProxyId(part, parent, force);
  }

  function encodeArrayPart(part, name, parent, force) {
    if (typeof part[0] === "number") {
      console.warn("Deprecated layoutData syntax: Percentage must be a string");
      return part.concat();
    }
    if (isPercentage(part[0])) {
      return [parseInt(part[0]), part[1]];
    }
    return [toProxyId(part[0], parent, force), part[1]];
  }

  function toProxyId(ref, parent, force) {
    if (typeof ref === "string") {
      var proxy = parent.children(ref)[0];
      if (!proxy && !force) {
        throw new Error();
      }
      return tabris.PropertyEncoding.proxy(proxy) || 0;
    }
    return tabris.PropertyEncoding.proxy(ref) || 0;
  }

  function isPercentage(value) {
    return typeof value === "string" && value[value.length - 1] === "%" && !isNaN(parseInt(value));
  }

  var emptyParent = {
    children: function() {
      return [];
    }
  };

  var directWidgetRef = {
    centerX: true,
    centerY: true,
    baseline: true
  };

}());

tabris.Properties = {

  set: function(arg1, arg2) {
    this._checkDisposed();
    if (typeof arg1 === "string") {
      this._setProperty(arg1, arg2);
    } else {
      this._setProperties(arg1);
    }
    return this;
  },

  get: function(name) {
    this._checkDisposed();
    if (this._props && name in this._props) {
      return this._props[name];
    }
    return this._readProperty(name);
  },

  _setProperties: function(properties) {
    for (var name in properties) {
      this._setProperty(name, properties[name]);
    }
  },

  _setProperty: function(name, value) {
    var accept = this._applyProperty(name, value);
    if (accept) {
      if (!this._props) {
        this._props = {};
      }
      this._props[name] = value;
    }
  },

  _checkDisposed: function() {},
  _applyProperty: function() {return true;},
  _readProperty: function() {return undefined;}

};

(function() {

  tabris.Proxy = function(cid) {
    this.cid = cid || generateId();
    tabris._proxies[this.cid] = this;
  };

  util.extend(tabris.Proxy.prototype, tabris.Events, tabris.Properties, {

    _create: function(properties) {
      var type = this.constructor._type || this.type;
      tabris._nativeBridge.create(this.cid, type);
      if (this.constructor && this.constructor._initProperties) {
        for (var name in this.constructor._initProperties) {
          this._nativeSet(name, this.constructor._initProperties[name]);
        }
      }
      this._setProperties(properties || {});
      return this;
    },

    dispose: function() {
      if (!this._isDisposed) {
        this._destroy();
        tabris._nativeBridge.destroy(this.cid);
        if (this._parent) {
          this._parent._removeChild(this);
        }
        this._isDisposed = true;
      }
    },

    _listen: function(type, state) {
      var event = this.constructor && this.constructor._events && this.constructor._events[type];
      if (!event) {
        return;
      }
      if (event.listen) {
        event.listen.call(this, state);
      } else {
        this._nativeListen(event.name, state);
      }
    },

    _nativeListen: function(event, state) {
      tabris._nativeBridge.listen(this.cid, event, state);
    },

    _trigger: function(event, params) {
      // TODO: all these && pre-checks can be removed once no one uses new tabris.Proxy anymore
      var name = this.constructor && this.constructor._trigger && this.constructor._trigger[event];
      var trigger = name && this.constructor._events[name].trigger;
      if (trigger instanceof Function) {
        trigger.call(this, params);
      } else if (name) {
        this.trigger(name, params);
      } else {
        this.trigger(event, params);
      }
    },

    _destroy: function() {
      this.trigger("dispose", {});
      this._destroyChildren();
      tabris.Events.off.call(this);
      delete tabris._proxies[this.cid];
    },

    _destroyChildren: function() {
    },

    _checkDisposed: function() {
      if (this._isDisposed) {
        throw new Error("Object is disposed");
      }
    },

    _applyProperty: function(name, value) {
      var type = this._getPropertyType(name);
      if (!type) {
        return true;
      }
      var encodedValue;
      try {
        encodedValue = this._encodeProperty(value, type, name);
      } catch (ex) {
        console.warn(this.type + ": Ignored unsupported value for property \"" + name + "\": " + ex.message);
        return false;
      }
      var setProperty = this._getPropertySetter(name);
      if (setProperty instanceof Function) {
        setProperty.call(this, encodedValue);
      } else {
        this._nativeSet(name, tabris.PropertyEncoding.proxy(encodedValue));
      }
    },

    _encodeProperty: function(value, type) {
      if (typeof type === "string" && tabris.PropertyEncoding[type]) {
        return tabris.PropertyEncoding[type](value);
      }
      if (Array.isArray(type) && tabris.PropertyEncoding[type[0]]) {
        var args = [value].concat(type.slice(1));
        return tabris.PropertyEncoding[type[0]].apply(window, args);
      }
      return value;
    },

    _decodeProperty: function(value, type) {
      if (typeof type === "string" && tabris.PropertyDecoding[type]) {
        return tabris.PropertyDecoding[type](value);
      }
      if (Array.isArray(type) && tabris.PropertyDecoding[type[0]]) {
        var args = [value].concat(type.slice(1));
        return tabris.PropertyDecoding[type[0]].apply(window, args);
      }
      return value;
    },

    _getPropertyType: function(name) {
      var prop = this.constructor && this.constructor._properties && this.constructor._properties[name];
      return typeof prop === "object" && prop.type ? prop.type : prop;
    },

    _getPropertySetter: function(name) {
      var prop = this.constructor && this.constructor._properties && this.constructor._properties[name];
      if (typeof prop === "object" && prop.set) {
        return prop.set;
      }
      return null;
    },

    _nativeSet: function(name, value) {
      tabris._nativeBridge.set(this.cid, name, value);
    },

    _readProperty: function(name) {
      var type = this._getPropertyType(name);
      if (!type) {
        return;
      }
      var getProperty = this._getPropertyGetter(name);
      var value = getProperty ? getProperty.call(this) : this._nativeGet(name);
      return this._decodeProperty(value, type);
    },

    _getPropertyGetter: function(name) {
      var prop = this.constructor && this.constructor._properties && this.constructor._properties[name];
      if (typeof prop === "object" && prop.get) {
        return prop.get;
      }
      return null;
    },

    _nativeGet: function(name) {
      return tabris._nativeBridge.get(this.cid, name);
    },

    _nativeCall: function(method, parameters) {
      this._checkDisposed();
      return tabris._nativeBridge.call(this.cid, method, parameters);
    }

  });

  var idSequence = 1;

  function generateId() {
    return "o" + (idSequence++);
  }

})();

(function() {

  tabris.ProxyCollection = function(arr, selector, deep) {
    this._array = select(arr, selector, deep);
    for (var i = 0; i < this._array.length; i++) {
      this[i] = this._array[i];
    }
    this.length = this._array.length;
  };

  var proto = tabris.ProxyCollection.prototype = {

    first: function() {
      return this._array[0];
    },

    last: function() {
      return this._array[this._array.length - 1];
    },

    toArray: function() {
      return this._array.concat();
    },

    forEach: function(callback) {
      var that = this;
      this._array.forEach(function(value, index) {
        callback(value, index, that);
      });
    },

    indexOf: function(needle) {
      return this._array.indexOf(needle);
    },

    filter: function(selector) {
      return new tabris.ProxyCollection(this._array, selector);
    },

    get: function(prop) {
      if (this._array[0]) {
        return this._array[0].get(prop);
      }
    },

    parent: function() {
      var result = [];
      for (var i = 0; i < this._array.length; i++) {
        var parent = this._array[i].parent();
        if (parent && result.indexOf(parent) === -1) {
          result.push(parent);
        }
      }
      if (result.length) {
        return new tabris.ProxyCollection(result);
      }
    },

    children: function(selector) {
      var result = [];
      for (var i = 0; i < this._array.length; i++) {
        result.push.apply(result, this._array[i]._children || []);
      }
      return new tabris.ProxyCollection(result, selector);
    },

    find: function(selector) {
      return new tabris.ProxyCollection(this.children()._array, selector, true);
    },

    appendTo: function(parent) {
      parent.append(this);
    },

    dispose: function() {
      for (var i = 0; i < this._array.length; i++) {
        this._array[i].dispose();
      }
    }

  };

  ["set", "animate", "on", "off"].forEach(function(key) {
    proto[key] = function() {
      for (var i = 0; i < this._array.length; i++) {
        this._array[i][key].apply(this._array[i], arguments);
      }
      return this;
    };
  });

  function select(array, selector, deep) {
    if (!array || array.length === 0) {
      return [];
    }
    if (!selector) {
      return array.concat();
    }
    var filter = getFilter(selector);
    if (deep) {
      return deepSelect([], array, filter);
    }
    return array.filter(filter);
  }

  function deepSelect(result, array, filter) {
    for (var i = 0; i < array.length; i++) {
      if (filter(array[i])) {
        result.push(array[i]);
      }
      if (array[i]._children) {
        deepSelect(result, array[i]._children, filter);
      }
    }
    return result;
  }

  function getFilter(selector) {
    var matches = {};
    var filter = selector instanceof Function ? selector : createMatcher(selector);
    return function(widget) {
      if (matches[widget.cid]) {
        return false;
      }
      if (filter(widget)) {
        matches[widget.cid] = true;
        return true;
      }
      return false;
    };
  }

  function createMatcher(selector) {
    if (selector.charAt(0) === "#") {
      var expectedId = selector.slice(1);
      return function(proxy) {
        return expectedId === proxy.id;
      };
    }
    if (selector === "*") {
      return function() {return true;};
    }
    return function(proxy) {
      return selector === proxy.type;
    };
  }

}());

(function() {

  tabris.PropertyDecoding = {

    color: function(value) {
      return util.colorArrayToString(value);
    },

    font: function(value) {
      return util.fontArrayToString(value);
    },

    image: function(value) {
      return util.imageFromArray(value);
    },

    bounds: function(value) {
      return {left: value[0], top: value[1], width: value[2], height: value[3]};
    }

  };

}());

(function() {

  tabris.PropertyEncoding = {

    boolean: function(bool) {
      return !!bool;
    },

    string: function(str) {
      return "" + str;
    },

    natural: function(number) {
      if (typeof number !== "number") {
        throw new Error(typeof number + " is not a number: " + number);
      }
      if (isNaN(number) || number === Infinity || number === -Infinity) {
        throw new Error("Number is not a valid value: " + number);
      }
      if (number < 0) {
        return 0;
      }
      return Math.round(number);
    },

    integer: function(number) {
      if (typeof number !== "number") {
        throw new Error(typeof number + " is not a number: " + number);
      }
      if (isNaN(number) || number === Infinity || number === -Infinity) {
        throw new Error("Number is not a valid value: " + number);
      }
      return Math.round(number);
    },

    choice: function(value, acceptable) {
      if (Array.isArray(acceptable)) {
        if (acceptable.indexOf(value) === -1) {
          throwNotAcceptedError(acceptable, value);
        }
        return value;
      }
      if (!(value in acceptable)) {
        throwNotAcceptedError(Object.keys(acceptable), value);
      }
      return acceptable[value];
    },

    color: function(value) {
      if (value === "initial") {
        return null;
      }
      return util.colorStringToArray(value);
    },

    font: function(value) {
      if (value === "initial") {
        return null;
      }
      return util.fontStringToArray(value);
    },

    image: function(value) {
      if (typeof value === "string") {
        value = {src: value};
      }
      if (!value || typeof value !== "object") {
        throw new Error("Not an image: " + value);
      }
      if (typeof value.src !== "string") {
        throw new Error("image.src is not a string");
      }
      if (value.src === "") {
        throw new Error("image.src is an empty string");
      }
      ["scale", "width", "height"].forEach(function(prop) {
        if (prop in value && !isDimension(value[prop])) {
          throw new Error("image." + prop + " is not a dimension: " + value[prop]);
        }
      });
      if ("scale" in value && ("width" in value || "height" in value)) {
        console.warn("Image scale is ignored if width or height are given");
      }
      return util.imageToArray(value);
    },

    layoutData: function(value) {
      return tabris.Layout.checkLayoutData(value);
    },

    bounds: function(value) {
      return [value.left, value.top, value.width, value.height];
    },

    proxy: function(value) {
      if (value instanceof tabris.Proxy) {
        return value.cid;
      }
      if (value instanceof tabris.ProxyCollection) {
        return value[0] ? value[0].cid : null;
      }
      return value;
    },

    nullable: function(value, altCheck) {
      if (value === null) {
        return value;
      }
      return tabris.PropertyEncoding[altCheck](value);
    }

  };

  function isDimension(value) {
    return typeof value === "number" && !isNaN(value) && value >= 0 && value !== Infinity;
  }

  function throwNotAcceptedError(acceptable, given) {
    var message = ["Accepting \""];
    message.push(acceptable.join("\", \""));
    message.push("\", given was: \"", given + "\"");
    throw new Error(message.join(""));
  }

}());

(function() {

  tabris.registerType("_Animation", {
    _type: "tabris.Animation",
    _events: {
      completion: "Completion",
      progress: "Progress",
      start: "Start"
    },
    _properties: {
      properties: true,
      delay: true,
      duration: true,
      repeat: true,
      reverse: true,
      easing: true,
      target: "proxy"
    }
  });

  tabris.Animation = function(target, properties, options) {
    var validatedOptions = {};
    var validatedProperties = {};
    for (var option in options) {
      if (validOptions[option]) {
        validatedOptions[option] = options[option];
      } else {
        console.warn("Invalid animation option \"" + option + "\"");
      }
    }
    for (var property in properties) {
      if (validProperties[property]) {
        validatedProperties[property] = properties[property];
      } else {
        console.warn("Invalid animation property \"" + property + "\"");
      }
    }
    this._target = target;
    // TODO: check/encode properties with PropertyEncoding.js
    this._properties = validatedProperties;
    this._options = validatedOptions;
  };

  util.extend(tabris.Animation.prototype, tabris.Events, {

    _start: function() {
      var animation = this;
      this._proxy = tabris.create("_Animation", util.extend(this._options, {
        target: this._target,
        properties: this._properties
      }));
      this._proxy._listen("completion", true);
      var animation = this;
      this._proxy.trigger = function() {
        animation.trigger.apply(animation, arguments);
        if (arguments[0] === "completion") {
          this.dispose();
          delete animation._proxy;
        }
      };
      this._proxy._nativeCall("start");
    },

    cancel: function() {
      if (this._proxy) {
        this._proxy._nativeCall("cancel");
      }
    },

    _listen: function(type) {
      if (type !== "completion" && this._proxy) {
        this._proxy._listen.apply(this._proxy, arguments);
      }
    }

  });

  tabris.Animation.animate = function(properties, options) {
    var animation = new tabris.Animation(this, properties, options);
    animation._start();
    return animation;
  };

  var validOptions = {
    delay: true,
    duration: true,
    repeat: true,
    reverse: true,
    easing: true
  };

  var validProperties = {
    opacity: true,
    transform: true
  };

}());

(function() {

  tabris.Widgets = {

    append: function() {
      this._checkDisposed();
      var proxies = arguments[0] instanceof tabris.ProxyCollection ? arguments[0].toArray() : arguments;
      for (var i = 0; i < proxies.length; i++) {
        if (!(proxies[i] instanceof tabris.Proxy)) {
          throw new Error("Cannot append non-widget");
        }
        proxies[i]._setParent(this);
      }
      return this;
    },

    appendTo: function(proxy) {
      this._checkDisposed();
      proxy = proxy instanceof tabris.ProxyCollection ? proxy.first() : proxy;
      if (!(proxy instanceof tabris.Proxy)) {
        throw new Error("Cannot append to non-widget");
      }
      this._setParent(proxy);
      return this;
    },

    parent: function() {
      return this._parent;
    },

    children: function(selector) {
      return new tabris.ProxyCollection(this._children, selector);
    },

    find: function(selector) {
      return new tabris.ProxyCollection(this._children, selector, true);
    },

    apply: function(sheet) {
      var scope = new tabris.ProxyCollection(this._children.concat(this), "*", true);
      if (sheet["*"]) {
        scope.set(sheet["*"]);
      }
      var selector;
      for (selector in sheet) {
        if (selector !== "*" && selector[0] !== "#") {
          scope.filter(selector).set(sheet[selector]);
        }
      }
      for (selector in sheet) {
        if (selector[0] === "#") {
          scope.filter(selector).set(sheet[selector]);
        }
      }
      return this;
    },

    _getContainer: function() {
      return this;
    },

    _setParent: function(parent) {
      tabris._nativeBridge.set(this.cid, "parent", tabris.PropertyEncoding.proxy(parent._getContainer()));
      if (this._parent) {
        this._parent._removeChild(this);
      }
      this._parent = parent;
      this._parent._addChild(this);
    },

    _addChild: function(child) {
      var check = this.constructor && this.constructor._supportsChildren;
      if (check === false) {
        throw new Error(this.type + " cannot contain children");
      }
      if (typeof check === "function" && !check(child)) {
        throw new Error(this.type + " cannot contain children of type " + child.type);
      }
      if (!this._children) {
        this._children = [];
      }
      this._children.push(child);
      this.trigger("addchild", child, this, {});
    },

    _removeChild: function(child) {
      if (this._children) {
        var index = this._children.indexOf(child);
        if (index !== -1) {
          this._children.splice(index, 1);
        }
        this.trigger("removechild", child, this, {index: index});
      }
    },

    _destroyChildren: function() {
      if (this._children) {
        for (var i = 0; i < this._children.length; i++) {
          this._children[i]._destroy();
        }
      }
    }

  };

  tabris.registerWidget = function(type, members) {
    members = util.extend({}, tabris.Widgets, tabris.Animation, members);
    members._events = util.extend({}, tabris.registerWidget._defaultEvents, members._events || {});
    if (members._properties !== true) {
      var defaultProperties = tabris.registerWidget._defaultProperties;
      members._properties = util.extend({}, defaultProperties, members._properties || {});
    }
    tabris.registerType(type, members);
  };

  var hasAndroidResizeBug;
  tabris.load(function() {
    hasAndroidResizeBug = tabris.device.get("platform") === "Android" &&
                          tabris.device.get("version") <= 17;
  });

  util.extend(tabris.registerWidget, {
    _defaultEvents: {
      touchstart: true,
      touchmove: true,
      touchend: true,
      touchcancel: true,
      longpress: true,
      dispose: function() {},
      "change:bounds": {
        name: "Resize",
        trigger: function(event) {
          if (hasAndroidResizeBug) {
            var self = this;
            setTimeout(function() {
              self.trigger("change:bounds", event);
            }, 0);
          } else {
            this.trigger("change:bounds", event);
          }
        }
      }
    },
    _defaultProperties: {
      enabled: "boolean",
      visible: {
        type: "boolean",
        set: function(value) {
          this._nativeSet("visibility", value);
        },
        get: function() {
          return this._nativeGet("visibility");
        }
      },
      layoutData: {
        type: "layoutData",
        set: function(value) {
          this._layoutData = value;
          try {
            renderLayoutData.call(this);
          } catch (ex) {
            if (!this._layoutDataPending) {
              tabris.on("beforeFlush", renderLayoutListener, this);
              this._layoutDataPending = true;
            }
          }
        },
        get: function() {
          return this._layoutData || null;
        }
      },
      font: "font",
      backgroundImage: "image",
      bounds: "bounds",
      background: "color",
      foreground: "color",
      opacity: true,
      transform: true,
      highlightOnTouch: "boolean",
      id: {
        type: "string",
        set: function(value) {
          this.id = value;
        },
        get: function() {
          return this.id;
        }
      }
    }
  });

  function renderLayoutListener() {
    try {
      renderLayoutData.call(this);
      tabris.off("beforeFlush", renderLayoutListener, this);
      delete this._layoutDataPending;
      delete this._hasPreliminaryLayout;
    } catch (ex) {
      if (!this._hasPreliminaryLayout) {
        renderLayoutData.call(this, true);
        this._hasPreliminaryLayout = true;

      }
    }
  }

  function renderLayoutData(force) {
    if (this._layoutData) {
      this._nativeSet("layoutData", tabris.Layout.encodeLayoutData(this._layoutData, this, force));
    } else {
      this._nativeSet("layoutData", null);
    }
  }

  tabris.registerWidget("Button", {
    _type: "rwt.widgets.Button",
    _initProperties: {style: ["PUSH"]},
    _events: {selection: "Selection"},
    _properties: {
      alignment: ["choice", ["left", "right", "center"]],
      image: "image",
      text: "string"
    }
  });

  tabris.registerWidget("Canvas", {
    _type: "rwt.widgets.Canvas",
    _supportsChildren: true
  });

  tabris.registerWidget("CheckBox", {
    _type: "rwt.widgets.Button",
    _initProperties: {style: ["CHECK"]},
    _events: {"change:selection": "Selection"},
    _properties: {text: "string", selection: "boolean"}
  });

  tabris.registerWidget("Picker", {
    _type: "rwt.widgets.Combo",
    _events: {"change:selection": "Selection"},
    _properties: {items: true, text: "string", selectionIndex: "natural"}
  });
  tabris.Combo = tabris.Picker;

  tabris.registerWidget("Composite", {
    _type: "rwt.widgets.Composite",
    _supportsChildren: true
  });

  tabris.registerWidget("ImageView", {
    _type: "tabris.ImageView",
    _properties: {
      image: "image",
      scaleMode: ["choice", ["auto", "fit", "fill", "stretch", "none"]]
    }
  });

  tabris.registerWidget("TextView", {
    _type: "tabris.TextView",
    _properties: {
      alignment: ["choice", ["left", "right", "center"]],
      markupEnabled: "boolean",
      maxLines: {
        type: ["nullable", "natural"],
        set: function(value) {
          this._nativeSet("maxLines", value <= 0 ? null : value);
        }
      },
      text: "string"
    }
  });
  tabris.Label = tabris.TextView;

  tabris.registerWidget("ProgressBar", {
    _type: "rwt.widgets.ProgressBar",
    _properties: {
      minimum: "integer",
      maximum: "integer",
      selection: "integer",
      state: ["choice", ["normal", "paused", "error"]]
    }
  });

  tabris.registerWidget("RadioButton", {
    _type: "rwt.widgets.Button",
    _initProperties: {style: ["RADIO"]},
    _events: {"change:selection": "Selection"},
    _properties: {text: "string", selection: "boolean"}
  });

  tabris.registerWidget("Slider", {
    _type: "rwt.widgets.Scale",
    _events: {"change:selection": "Selection"},
    _properties: {minimum: "integer", maximum: "integer", selection: "integer"}
  });

  tabris.registerWidget("TextInput", {
    _type: "tabris.TextInput",
    _events: {
      focus: true,
      blur: true,
      accept: true,
      "change:text": "modify"
    },
    _properties: {
      type: ["choice", ["default", "password", "search", "multiline"]],
      text: "string",
      message: "string",
      editable: "boolean",
      alignment: ["choice", ["left", "center", "right"]],
      autoCorrect: "boolean",
      autoCapitalize: "boolean",
      keyboard: ["choice", ["ascii", "decimal", "email", "number", "numbersAndPunctuation", "phone", "url", "default"]]
    }
  });
  tabris.Text = tabris.TextInput;

  tabris.registerWidget("ToggleButton", {
    _type: "rwt.widgets.Button",
    _initProperties: {style: ["TOGGLE"]},
    _events: {"change:selection": "Selection"},
    _properties: {
      text: "string",
      image: "image",
      selection: "boolean",
      alignment: ["choice", ["left", "right", "center"]]
    }
  });

  tabris.registerWidget("Video", {
    _type: "tabris.widgets.Video",
    _initProperties: {controls_visible: true, repeat: false},
    _properties: {url: true}
  });

  tabris.registerWidget("WebView", {
    _type: "rwt.widgets.Browser",
    _events: {load: "Progress"},
    _properties: {url: true, html: "string"}
  });

}());

(function() {

  var noop = function() {};

  tabris.DOMEvent = function(type, eventInitDict) {
    this.type = type;
    this.timeStamp = Date.now();
    if (typeof eventInitDict !== "undefined") {
      if ("bubbles" in eventInitDict) {
        this.bubbles = eventInitDict.bubbles;
      }
      if ("cancelable" in eventInitDict) {
        this.cancelable = eventInitDict.cancelable;
      }
    }
  };

  tabris.DOMEvent.prototype = {
    NONE: 0,
    CAPTURING_PHASE: 1,
    AT_TARGET: 2,
    BUBBLING_PHASE: 3,
    target: null,
    currentTarget: null,
    eventPhase: 0,
    type: "",
    bubbles: false,
    cancelable: false,
    defaultPrevented: false,
    isTrusted: false,
    stopPropagation: noop,
    stopImmediatePropagation: noop,
    preventDefault: noop,
    initEvent: function(type, bubbles, cancelable) {
      this.type = type;
      this.bubbles = bubbles;
      this.cancelable = cancelable;
    }
  };

  tabris._addDOMEventTargetMethods = function(target) {

    if (typeof target.addEventListener === "function") {
      return;
    }

    var listeners;

    target.addEventListener = function(type, listener /*, useCapture*/) {
      if (!listeners) {
        listeners = [];
      }
      if (!(type in listeners)) {
        listeners[type] = [];
      }
      var index = listeners[type].indexOf(listener);
      if (index === -1) {
        listeners[type].push(listener);
      }
      return listeners[type].length === 1;
    };

    target.removeEventListener = function(type, listener /*, useCapture*/) {
      if (listeners && type in listeners) {
        var index = listeners[type].indexOf(listener);
        if (index !== -1) {
          listeners[type].splice(index, 1);
          return listeners[type].length === 0;
        }
      }
      return false;
    };

    target.dispatchEvent = function(event) {
      if (listeners && event.type in listeners) {
        var eventListeners = listeners[event.type];
        for (var i = 0; i < eventListeners.length; i++) {
          eventListeners[i].call(this, event);
        }
      }
    };

  };

  if (typeof window !== "undefined") {
    tabris._addDOMEventTargetMethods(window);
    if (!window.Event) {
      window.Event = tabris.DOMEvent;
    }
  }

}());

(function() {

  var noop = function() {};
  var HTMLElement = function(tagName) {
    this.tagName = (tagName || "").toUpperCase();
    this.children = [];
  };
  HTMLElement.prototype = {
    setAttribute: noop,
    appendChild: function(el) {
      this.children.push(el);
      handleElementInserted(this, el);
      return el;
    },
    cloneNode: function() {return new HTMLElement();},
    lastChild: function() {return new HTMLElement();}
  };

  tabris._addDOMDocument = function(target) {
    target.document = {
      documentElement: {},
      createDocumentFragment: function() {return new HTMLElement();},
      createElement: function(tagName) {return new HTMLElement(tagName);},
      location: {href: ""},
      readyState: "loading",
      head: new HTMLElement("head"),
      getElementsByTagName: function(tagName) {
        return this.head.children.filter(function(node) {
          return node.tagName === tagName.toUpperCase();
        });
      },
      createEvent: function() {
        return new tabris.DOMEvent();
      }
    };
    tabris._addDOMEventTargetMethods(target.document);
    if (typeof target.location === "undefined") {
      target.location = target.document.location;
    }
    tabris.load(function() {
      target.document.readyState = "complete";
      var event = document.createEvent("Events");
      event.initEvent("DOMContentLoaded", false, false);
      target.document.dispatchEvent(event);
    });
    target.navigator = {
      userAgent: "tabris-js" // TODO: identify OS/device?
    };
  };

  if (typeof window !== "undefined" && !window.document) {
    tabris._addDOMDocument(window);
  }

  function handleElementInserted(parent, child) {
    if (parent.tagName === "HEAD" && child.tagName === "SCRIPT" && child.src) {
      var result;
      try {
        result = tabris._client.loadAndExecute(child.src, "", "");
      } catch (ex) {
        console.error("Error loading " + child.src + ": " + ex);
        console.log(ex.stack);
        if (typeof child.onerror === "function") {
          child.onerror.call(window, ex);
        }
        return;
      }
      if (result.loadError) {
        if (typeof child.onerror === "function") {
          child.onerror.call(window, new Error("Could not load " + child.src));
        }
      } else if (typeof child.onload === "function") {
        child.onload.call(window);
      }
    }
  }

}());

(function() {

  tabris.registerType("_Timer", {
    _type: "tabris.Timer",
    _events: {Run: true},
    _properties: {delay: true, repeat: true}
  });

  tabris._addWindowTimerMethods = function(target) {

    if (typeof target.setTimeout === "function") {
      return;
    }

    var taskSequence = 0;
    var timers = {};

    function createTimer(fn, delay, repeat) {
      var taskId = taskSequence++;
      // If tabris is not ready, create the timer on load.
      // However, clearTimeout won't work until after load.
      tabris.load(function() {
        var timer = tabris.create("_Timer", {
          delay: delay,
          repeat: repeat
        }).on("Run", function() {
          fn.call();
          if (!repeat) {
            timer.dispose();
            delete timers[taskId];
          }
        });
        timer._nativeCall("start");
        timers[taskId] = timer;
      });
      return taskId;
    }

    target.setTimeout = function(fn, delay) {
      return createTimer(fn, delay, false);
    };

    target.setInterval = function(fn, delay) {
      return createTimer(fn, delay, true);
    };

    target.clearTimeout = target.clearInterval = function(taskId) {
      var timer = timers[taskId];
      if (timer) {
        timer._nativeCall("cancel", {});
        timer.dispose();
        delete timers[taskId];
      }
    };

  };

  if (typeof window !== "undefined") {
    tabris._addWindowTimerMethods(window);
  }

})();

(function() {

  tabris.registerType("_Device", {
    _type: "tabris.Device",
    _properties: {
      model: true,
      platform: true,
      version: true,
      language: true,
      orientation: true,
      screenWidth: true,
      screenHeight: true,
      scaleFactor: true
    },
    _setProperty: function() {},
    _events: {
      "change:orientation": {
        name: "orientationchange",
        trigger: function(event) {
          this.trigger("change:orientation", {value: event.orientation});
        }
      }
    },
    dispose: function() {
      throw new Error("cannot dispose device object");
    }
  });

  tabris._publishDeviceProperties = function(target) {
    if (!("device" in target)) {
      defineReadOnlyProperty(target, "device", fix(createDeviceObject()));
    }
    if (!("screen" in target)) {
      defineReadOnlyProperty(target, "screen", fix(createScreenObject()));
    }
    if (("navigator" in target) && !("language" in target.navigator)) {
      defineReadOnlyProperty(target.navigator, "language", getDevicePropertyFn("language"));
    }
    if (!("devicePixelRatio" in target)) {
      defineReadOnlyProperty(target, "devicePixelRatio", getDevicePropertyFn("scaleFactor"));
    }
  };

  tabris.device = tabris("_Device");

  if (typeof window !== "undefined") {
    tabris._publishDeviceProperties(window);
  }

  function createDeviceObject() {
    var dev = {};
    ["model", "platform", "version"].forEach(function(name) {
      defineReadOnlyProperty(dev, name, getDevicePropertyFn(name));
    });
    return dev;
  }

  function createScreenObject() {
    var screen = {};
    defineReadOnlyProperty(screen, "width", getDevicePropertyFn("screenWidth"));
    defineReadOnlyProperty(screen, "height", getDevicePropertyFn("screenHeight"));
    return screen;
  }

  function defineReadOnlyProperty(target, name, getter) {
    Object.defineProperty(target, name, {
      get: getter,
      set: function() {}
    });
  }

  function getDevicePropertyFn(name) {
    return function() {
      return tabris.device.get(name);
    };
  }

  function fix(value) {
    return function() {
      return value;
    };
  }

})();

tabris.registerType("_App", {
  _type: "tabris.App",
  _events: {pause: "Pause", resume: "Resume"},
  dispose: function() {
    throw new Error("tabris.app can not be disposed");
  }
});

tabris.app = tabris("_App");

tabris.registerType("_Display", {
  _type: "rwt.widgets.Display"
});

tabris.registerWidget("_Shell", {
  _type: "rwt.widgets.Shell",
  _events: {Close: true},
  _properties: {
    style: true,
    mode: true,
    active: true
  }
});

tabris.registerType("_UI", {

  _type: "tabris.UI",

  _events: {ShowPage: true, ShowPreviousPage: true},

  _create: function() {
    tabris.create("_Display");
    this._shell = tabris.create("_Shell", {
      style: ["NO_TRIM"],
      mode: "maximized",
      active: true,
      visible: true
    }).on("Close", function() {
      this.dispose();
    });
    tabris.Proxy.prototype._create.call(this, {});
    this._nativeSet("shell", this._shell.cid);
    this._pages = [];
    this.on("ShowPage", function(properties) {
      var page = tabris._proxies[properties.pageId];
      this._setActivePage(page.widget);
    }).on("ShowPreviousPage", function() {
      var page = this._getActivePage();
      if (page) {
        page.close();
      }
    });
    return this;
  },

  _properties: {
    image: "image",
    foreground: "color",
    background: "color",
    activePage: {
      set: function(page) {
        this._setActivePage(page);
      },
      get: function() {
        return this._getActivePage();
      }
    }
  },

  _setActivePage: function(page) {
    if (!(page instanceof tabris.Page)) {
      console.warn("Value for activePage is not a page");
      return;
    }
    var activePage = this._getActivePage();
    if (page !== activePage) {
      page.on("dispose", this._pageClosed.bind(this, page));
      this._pages.push(page);
      this._updateActivePage(activePage, page);
    }
  },

  _getActivePage: function() {
    return this._pages[this._pages.length - 1];
  },

  _pageClosed: function(closedPage) {
    var oldActivePage = this._getActivePage();
    this._pages = this._pages.filter(function(page) {
      return page !== closedPage;
    });
    var newActivePage = this._getActivePage();
    if (newActivePage !== oldActivePage) {
      this._updateActivePage(oldActivePage, this._getActivePage());
    }
  },

  _updateActivePage: function(oldPage, newPage) {
    if (oldPage) {
      oldPage.trigger("disappear");
    }
    this._nativeSet("activePage", newPage._page.cid);
    newPage.trigger("appear");
  }

});

tabris.load(function() {
  tabris.ui = tabris.create("_UI");
});

(function() {

  tabris.registerWidget("CollectionView", {

    _type: "tabris.CollectionView",

    _properties: {
      itemHeight: "natural",
      items: {
        set: function(value) {
          this._setItems(value);
        },
        get: function() {
          return this._items.concat();
        }
      },
      initializeCell: {
        set: function(value) {
          this._initializeCell = value;
        }
      },
      refreshEnabled: "boolean",
      refreshIndicator: "boolean",
      refreshMessage: "string"
    },

    _create: function() {
      this._items = [];
      var result = tabris.Proxy.prototype._create.apply(this, arguments);
      this._nativeListen("createitem", true);
      this._nativeListen("populateitem", true);
      // TODO call _reload on flush
      this._reload();
      return result;
    },

    set: function() {
      var result = tabris.Proxy.prototype.set.apply(this, arguments);
      // TODO call _reload on flush, remove override
      this._reload();
      return result;
    },

    _events: {
      refresh: true,
      createitem: {
        trigger: function() {
          var cell = tabris.create("_CollectionCell", {});
          this._nativeCall("addItem", {widget: cell.cid});
          if (typeof this._initializeCell !== "function") {
            console.warn("initializeCell callback missing");
          } else {
            this._initializeCell(cell);
          }
        }
      },
      populateitem: {
        trigger: function(event) {
          var cell = tabris(event.widget);
          var item = this._getItem(this._items, event.index);
          cell.trigger("itemchange", item, event.index);
        }
      },
      selection: {
        trigger: function(event) {
          this.trigger("selection", {
            index: event.index,
            item: this._getItem(this._items, event.index)
          });
        }
      }
    },

    _setItems: function(items) {
      this._items = items ? items.concat() : [];
      this._needsReload = true;
    },

    _getItem: function(items, index) {
      return items[index];
    },

    reveal: function(index) {
      index = this._checkIndex(index);
      if (index >= 0 && index < this._items.length) {
        this._nativeCall("reveal", {index: index});
      }
    },

    refresh: function(index) {
      if (arguments.length === 0) {
        this._nativeCall("update", {reload: [0, this._items.length]});
        return;
      }
      index = this._checkIndex(index);
      if (index >= 0 && index < this._items.length) {
        this._nativeCall("update", {reload: [index, 1]});
      }
    },

    insert: function(items, index) {
      if (!Array.isArray(items)) {
        throw new Error("items is not an array");
      }
      if (arguments.length === 1) {
        index = this._items.length;
      } else {
        index = Math.max(0, Math.min(this._items.length, this._checkIndex(index)));
      }
      Array.prototype.splice.apply(this._items, [index, 0].concat(items));
      this._nativeCall("update", {insert: [index, items.length]});
    },

    remove: function(index, count) {
      index = this._checkIndex(index);
      if (arguments.length === 1) {
        count = 1;
      } else if (typeof count === "number" && isFinite(count) && count >= 0) {
        count = Math.min(count, this._items.length - index);
      } else {
        throw new Error("illegal remove count");
      }
      if (index >= 0 && index < this._items.length && count > 0) {
        this._items.splice(index, count);
        this._nativeCall("update", {remove: [index, count]});
      }
    },

    _reload: function() {
      // We defer the reload call until the end of create/set in order to ensure that
      // we don't receive events before the listeners are attached
      if (this._needsReload) {
        this._nativeCall("reload", {"items": this._items.length});
        delete this._needsReload;
      }
    },

    _checkIndex: function(index) {
      if (typeof index !== "number" || !isFinite(index)) {
        throw new Error("illegal index");
      }
      return index < 0 ? index + this._items.length : index;
    }

  });

  tabris.registerWidget("_CollectionCell", {

    _type: "rwt.widgets.Composite",

    _supportsChildren: true,

    dispose: function() {
      console.warn("CollectionView cells are container-managed, they cannot be disposed of");
    }

  });

})();

tabris.registerWidget("_ScrollBar", {
  _type: "rwt.widgets.ScrollBar",
  _events: {Selection: true},
  _properties: {
    style: true
  }
});

tabris.registerWidget("ScrollComposite", {

  _type: "rwt.widgets.ScrolledComposite",

  _supportsChildren: true,

  _events: {
    scroll: {
      listen: function(listen) {
        if (listen) {
          this._scrollBar.on("Selection", this._scrollBarListener, this);
        } else {
          this._scrollBar.off("Selection", this._scrollBarListener, this);
        }
      }
    }
  },

  _create: function(properties) {
    var scrollProps = util.omit(properties, ["direction"]);
    this.super("_create", scrollProps);
    var style = properties.direction === "horizontal" ? ["H_SCROLL"] : ["V_SCROLL"];
    this._nativeSet("style", style);
    this._scrollBar = tabris.create("_ScrollBar", {
      style: properties.direction === "horizontal" ? ["HORIZONTAL"] : ["VERTICAL"]
    });
    tabris._nativeBridge.set(this._scrollBar.cid, "parent", this.cid);
    this._composite = tabris.create("Composite");
    tabris._nativeBridge.set(this._composite.cid, "parent", this.cid);
    this._nativeSet("content", this._composite.cid);
    return this;
  },

  _scrollBarListener: function() {
    var selection = this._nativeGet("origin");
    this.trigger("scroll", {x: selection[0], y: selection[1]});
  },

  _getContainer: function() {
    return this._composite;
  }

});

(function() {

  var pageProperties = ["title", "image", "style", "topLevel"];

  tabris.registerWidget("_Page", {
    _type: "tabris.Page",

    _properties: {
      image: "image",
      title: "string",
      topLevel: "boolean",
      control: "proxy",
      parent: "proxy",
      style: true
    }

  });

  tabris.registerWidget("Page", {

    _type: "rwt.widgets.Composite",

    _supportsChildren: true,

    _properties: {
      image: true,
      title: true,
      topLevel: true
    },

    _create: function(properties) {
      this.super("_create",  util.extend(util.omit(properties, pageProperties), {
        layoutData: {left: 0, right: 0, top: 0, bottom: 0}
      }));
      this._nativeSet("parent", tabris.ui._shell.cid);
      this._page = tabris.create("_Page", util.extend(util.pick(properties, pageProperties), {
        parent: tabris.ui,
        control: this
      }));
      this._page.widget = this;
      return this;
    },

    dispose: function() {
      this._page.dispose();
      this.super("dispose");
    },

    open: function() {
      tabris.ui.set("activePage", this);
      return this;
    },

    close: function() {
      this.dispose();
    }

  });

  pageProperties.forEach(function(property) {
    var type = tabris.Page._properties[property];
    tabris.Page._properties[property] = {
      type: type,
      set: function(value) {this._page.set(property, value);},
      get: function() {return this._page.get(property);}
    };
  });

}());

tabris.registerType("Action", {

  _type: "tabris.Action",

  _properties: {
    enabled: "boolean",
    foreground: "color",
    image: "image",
    placementPriority: {
      type: ["choice", {low: "LOW", high: "HIGH", normal: "NORMAL"}],
      get: function() {
        var value = this._nativeGet("placementPriority");
        return value ? value.toLowerCase() : value;
      }
    },
    title: "string",
    visible: {
      type: "boolean",
      set: function(value) {
        this._nativeSet("visibility", value);
      },
      get: function() {
        return this._nativeGet("visibility");
      }
    }
  },

  _events: {selection: "Selection"},

  _create: function(properties) {
    this.super("_create", properties);
    this._nativeSet("parent", tabris.ui.cid);
    return this;
  }

});

tabris.registerType("SearchAction", {

  _type: "tabris.SearchAction",

  _properties: {
    enabled: "boolean",
    foreground: "color",
    image: "image",
    placementPriority: {
      type: ["choice", {low: "LOW", high: "HIGH", normal: "NORMAL"}],
      get: function() {
        var value = this._nativeGet("placementPriority");
        return value ? value.toLowerCase() : value;
      }
    },
    title: "string",
    visible: {
      type: "boolean",
      set: function(value) {
        this._nativeSet("visibility", value);
      },
      get: function() {
        return this._nativeGet("visibility");
      }
    },
    proposals: true // array of strings
  },

  _events: {selection: "Selection", modify: "Modify", submit: "Search"},

  _create: function(properties) {
    this.super("_create", properties);
    this._nativeSet("parent", tabris.ui.cid);
    return this;
  }

});

(function() {

  tabris.registerWidget("_TabItem", {
    _type: "rwt.widgets.TabItem",
    _properties: {
      text: true,
      image: true,
      badge: true,
      control: true,
      index: true
    }
  });

  tabris.registerWidget("TabFolder", {

    _type: "rwt.widgets.TabFolder",

    _create: function(properties) {
      this.super("_create", util.omit(properties, "tabBarLocation"));
      if (properties.tabBarLocation === "top") {
        this._nativeSet("style", ["TOP"]);
      } else if (properties.tabBarLocation === "bottom") {
        this._nativeSet("style", ["BOTTOM"]);
      }
      return this;
    },

    _properties: {
      paging: {
        type: "boolean",
        set: function(value) {
          this._paging = value;
          this._nativeSet("data", {paging: value});
        },
        get: function() {
          return !!this._paging;
        }
      },
      selection: {
        set: function(tab) {
          if (!(tab instanceof tabris.Tab)) {
            console.warn("Can not set TabFolder selection to " + tab);
            return;
          }
          if (tab._isDisposed) {
            console.warn("Can not set TabFolder selection to disposed Tab");
            return;
          }
          this._nativeSet("selection", tab._tabItem.cid);
        },
        get: function() {
          var selection = this._nativeGet("selection");
          return selection ? tabris(selection)._tab : null;
        }
      }
    },

    _supportsChildren: function(child) {
      return child.type === "Tab" || child.type === "_TabItem";
    },

    _events: {"change:selection": "Selection"},

    _getItems: function() {
      return this._children ? this._children.filter(isItem) : new tabris.ProxyCollection();
    },

    children: function() {
      return this._children ? this._children.filter(isTab) : new tabris.ProxyCollection();
    }

  });

  tabris.registerWidget("Tab", {

    _type: "rwt.widgets.Composite",

    _properties: {
      title: {
        type: "string",
        set: function(value) {
          this._setItemProperty("text", value);
        }
      },
      image: {
        type: "image",
        set: function(value) {
          this._setItemProperty("image", value);
        }
      },
      badge: {
        type: "string",
        set: function(value) {
          this._setItemProperty("badge", value);
        }
      }
    },

    _supportsChildren: true,

    _create: function(properties) {
      this._itemProps = {};
      return this.super("_create", properties);
    },

    _setItemProperty: function(name, value) {
      if (this._tabItem) {
        this._tabItem._setProperty(name, value);
      } else {
        this._itemProps[name] = value;
      }
    },

    get: function(name) {
      if (isItemProp(name)) {
        if (this._tabItem) {
          return this._tabItem.get(translateItemProp(name));
        }
        var result = this._itemProps[translateItemProp(name)];
        if (name === "image") {
          return tabris.PropertyDecoding.image(result);
        }
        return result;
      }
      return this.super("get", name);
    },

    _setParent: function(parent) {
      if (!(parent instanceof tabris.TabFolder)) {
        throw new Error("Tab must be a child of TabFolder");
      }
      tabris.Widgets._setParent.call(this, parent);
      this._tabItem = tabris.create("_TabItem", util.extend({
        control: this.cid,
        index: parent._getItems().length
      }, this._itemProps)).appendTo(parent);
      this._tabItem._tab = this;
    },

    _destroy: function() {
      if (this._tabItem) {
        this._tabItem.dispose();
      }
    }

  });

  function isItemProp(name) {
    return ["title", "image", "badge"].indexOf(name) !== -1;
  }

  function translateItemProp(name) {
    return name === "title" ? "text" : name;
  }

  function isTab(child) {
    return child instanceof tabris.Tab;
  }

  function isItem(child) {
    return !isTab(child);
  }

}());

(function() {

  tabris.registerType("_GC", {
    _type: "rwt.widgets.GC",
    _properties: {parent: true}
  });

  tabris.CanvasContext = function(gc) {
    this._gc = gc;
    this._state = createState();
    this._savedStates = [];
    this._opCodes = [];
    this._newOpCodes = [];
    this._operations = [];
    this._ints = [];
    this._doubles = [];
    this._booleans = [];
    this._strings = [];

    this.canvas = {
      width: 0,
      height: 0,
      style: {}
    };
    for (var name in properties) {
      defineProperty(this, name);
    }
    tabris.on("flush", this._flush, this);
    gc.on("dispose", function() {
      tabris.off("flush", this._flush, this);
    }, this);
  };

  tabris.CanvasContext.prototype = {

    save: function() {
      this._pushOperation("save");
      this._savedStates.push(util.clone(this._state));
    },

    restore: function() {
      this._pushOperation("restore");
      this._state = this._savedStates.pop() || this._state;
    },

    // Path operations

    beginPath: function() {
      this._pushOperation("beginPath");
    },

    closePath: function() {
      this._pushOperation("closePath");
    },

    lineTo: function(x, y) {
      this._pushOperation("lineTo");
      this._doubles.push(x, y);
    },

    moveTo: function(x, y) {
      this._pushOperation("moveTo");
      this._doubles.push(x, y);
    },

    bezierCurveTo: function(cp1x, cp1y, cp2x, cp2y, x, y) {
      this._pushOperation("bezierCurveTo");
      this._doubles.push(cp1x, cp1y, cp2x, cp2y, x, y);
    },

    quadraticCurveTo: function(cpx, cpy, x, y) {
      this._pushOperation("quadraticCurveTo");
      this._doubles.push(cpx, cpy, x, y);
    },

    rect: function(x, y, width, height) {
      this._pushOperation("rect");
      this._doubles.push(x, y, width, height);
    },

    arc: function(x, y, radius, startAngle, endAngle, anticlockwise) {
      this._pushOperation("arc");
      this._doubles.push(x, y, radius, startAngle, endAngle);
      this._booleans.push(!!anticlockwise);
    },

    // Transformations

    scale: function(x, y) {
      this._pushOperation("scale");
      this._doubles.push(x, y);
    },

    rotate: function(angle) {
      this._pushOperation("rotate");
      this._doubles.push(angle);
    },

    translate: function(x, y) {
      this._pushOperation("translate");
      this._doubles.push(x, y);
    },

    transform: function(a, b, c, d, e, f) {
      this._pushOperation("transform");
      this._doubles.push(a, b, c, d, e, f);
    },

    setTransform: function(a, b, c, d, e, f) {
      this._pushOperation("setTransform");
      this._doubles.push(a, b, c, d, e, f);
    },

    // Drawing operations

    clearRect: function(x, y, width, height) {
      this._pushOperation("clearRect");
      this._doubles.push(x, y, width, height);
    },

    fillRect: function(x, y, width, height) {
      this._pushOperation("beginPath");
      this._pushOperation("rect");
      this._doubles.push(x, y, width, height);
      this.fill();
    },

    strokeRect: function(x, y, width, height) {
      this._pushOperation("beginPath");
      this._pushOperation("rect");
      this._doubles.push(x, y, width, height);
      this.stroke();
    },

    fillText: function(text, x, y /* , maxWidth */) {
      this._pushOperation("fillText");
      this._strings.push(text);
      this._booleans.push(false, false, false);
      this._doubles.push(x, y);

    },

    strokeText: function(text, x, y /* , maxWidth */) {
      this._pushOperation("strokeText");
      this._strings.push(text);
      this._booleans.push(false, false, false);
      this._doubles.push(x, y);
    },

    fill: function() {
      this._pushOperation("fill");
    },

    stroke: function() {
      this._pushOperation("stroke");
    },

    measureText: function(text) {
      // TODO wire to native function
      return {width: text.length * 5 + 5};
    },

    _init: function(width, height) {
      this.canvas.width = width;
      this.canvas.height = height;
      this._gc._nativeCall("init", {
        width: width,
        height: height,
        font: [["sans-serif"], 12, false, false],
        fillStyle: [0, 0, 0, 255],
        strokeStyle: [0, 0, 0, 255]
      });
    },

    _flush: function() {
      if (this._operations.length > 0) {
        this._gc._nativeCall("draw", {packedOperations: [
          this._newOpCodes,
          this._operations,
          this._doubles,
          this._booleans,
          this._strings,
          this._ints
        ]});
        this._operations = [];
        this._doubles = [];
        this._booleans = [];
        this._strings = [];
        this._ints = [];
        this._newOpCodes = [];
      }
    },

    _pushOperation: function(operation) {
      if (this._opCodes.indexOf(operation) < 0) {
        this._newOpCodes.push(operation);
        this._opCodes.push(operation);
      }
      this._operations.push(this._opCodes.indexOf(operation));
    }
  };

  tabris.getContext = function(canvas, width, height) {
    if (!canvas._gc) {
      canvas._gc = tabris.create("_GC", {parent: canvas});
    }
    if (!canvas._ctx) {
      canvas._ctx = device.platform === "Android" ? new tabris.CanvasContext(canvas._gc)
                                                  : new tabris.LegacyCanvasContext(canvas._gc);
    }
    canvas._ctx._init(width, height);
    return canvas._ctx;
  };

  var properties = {
    lineWidth: {
      init: 1,
      encode: function(value) {
        if (value > 0) {
          return value;
        }
        throw new Error(value);
      },
      decode: passThrough,
      addOperations: function(context, value) {
        context._pushOperation("lineWidth");
        context._doubles.push(value);
      }
    },
    lineCap: {
      init: "butt",
      values: toObject(["butt", "round", "square"]),
      encode: checkValue,
      decode: passThrough,
      addOperations: function(context, value) {
        context._pushOperation("lineCap");
        context._strings.push(value);
      }
    },
    lineJoin: {
      init: "miter",
      values: toObject(["bevel", "miter", "round"]),
      encode: checkValue,
      decode: passThrough,
      addOperations: function(context, value) {
        context._pushOperation("lineJoin");
        context._strings.push(value);
      }
    },
    fillStyle: {
      init: [0, 0, 0, 255],
      encode: util.colorStringToArray,
      decode: util.colorArrayToString,
      addOperations: function(context, value) {
        context._pushOperation("fillStyle");
        context._ints.push(value[0], value[1], value[2], value[3]);
      }
    },
    strokeStyle: {
      init: [0, 0, 0, 255],
      encode: util.colorStringToArray,
      decode: util.colorArrayToString,
      addOperations: function(context, value) {
        context._pushOperation("strokeStyle");
        context._ints.push(value[0], value[1], value[2], value[3]);
      }
    },
    textAlign: {
      init: "start",
      values: toObject(["start", "end", "left", "right", "center"]),
      encode: checkValue,
      decode: passThrough,
      addOperations: function(context, value) {
        context._pushOperation("textAlign");
        context._strings.push(value);
      }
    },
    textBaseline: {
      init: "alphabetic",
      values: toObject(["top", "hanging", "middle", "alphabetic", "ideographic", "bottom"]),
      encode: checkValue,
      decode: passThrough,
      addOperations: function(context, value) {
        context._pushOperation("textBaseline");
        context._strings.push(value);
      }
    }
  };

  function passThrough(value) {
    return value;
  }

  function checkValue(value) {
    if (value in this.values) {
      return value;
    }
    throw new Error(value);
  }

  function toObject(array) {
    var obj = {};
    array.forEach(function(name) {
      obj[name] = true;
    });
    return obj;
  }

  function createState() {
    var state = {};
    for (var name in properties) {
      state[name] = properties[name].init;
    }
    return state;
  }

  function defineProperty(context, name) {
    var prop = properties[name];
    Object.defineProperty(context, name, {
      get: function() {
        return prop.decode(context._state[name]);
      },
      set: function(value) {
        try {
          context._state[name] = prop.encode(value);
          prop.addOperations(context, context._state[name]);
        } catch (error) {
          console.warn("Unsupported value for " + name + ": " + value);
        }
      }
    });
  }

}());

(function() {

  tabris.LegacyCanvasContext = function(gc) {
    this._gc = gc;
    this._state = createState();
    this._savedStates = [];
    this._operations = [];
    this.canvas = {
      width: 0,
      height: 0,
      style: {}
    };
    for (var name in properties) {
      defineProperty(this, name);
    }
    tabris.on("flush", this._flush, this);
    gc.on("dispose", function() {
      tabris.off("flush", this._flush, this);
    }, this);
  };

  tabris.LegacyCanvasContext.prototype = {

    save: function() {
      this._operations.push(["save"]);
      this._savedStates.push(util.clone(this._state));
    },

    restore: function() {
      this._operations.push(["restore"]);
      this._state = this._savedStates.pop() || this._state;
    },

    // Path operations

    beginPath: function() {
      this._operations.push(["beginPath"]);
    },

    closePath: function() {
      this._operations.push(["closePath"]);
    },

    lineTo: function(x, y) {
      this._operations.push(["lineTo", x, y]);
    },

    moveTo: function(x, y) {
      this._operations.push(["moveTo", x, y]);
    },

    bezierCurveTo: function(cp1x, cp1y, cp2x, cp2y, x, y) {
      this._operations.push(["bezierCurveTo", cp1x, cp1y, cp2x, cp2y, x, y]);
    },

    quadraticCurveTo: function(cpx, cpy, x, y) {
      this._operations.push(["quadraticCurveTo", cpx, cpy, x, y]);
    },

    rect: function(x, y, width, height) {
      this._operations.push(["rect", x, y, width, height]);
    },

    arc: function(x, y, radius, startAngle, endAngle, anticlockwise) {
      this._operations.push(["arc", x, y, radius, startAngle, endAngle, !!anticlockwise]);
    },

    // Transformations

    scale: function(x, y) {
      this._operations.push(["scale", x, y]);
    },

    rotate: function(angle) {
      this._operations.push(["rotate", angle]);
    },

    translate: function(x, y) {
      this._operations.push(["translate", x, y]);
    },

    transform: function(a, b, c, d, e, f) {
      this._operations.push(["transform", a, b, c, d, e, f]);
    },

    setTransform: function(a, b, c, d, e, f) {
      this._operations.push(["setTransform", a, b, c, d, e, f]);
    },

    // Drawing operations

    clearRect: function(x, y, width, height) {
      this._operations.push(["clearRect", x, y, width, height]);
    },

    fillRect: function(x, y, width, height) {
      this._operations.push(["beginPath"], ["rect", x, y, width, height]);
      this.fill();
    },

    strokeRect: function(x, y, width, height) {
      this._operations.push(["beginPath"], ["rect", x, y, width, height]);
      this.stroke();
    },

    fillText: function(text, x, y /*, maxWidth*/) {
      this._operations.push(["fillText", text, false, false, false, x, y]);
    },

    strokeText: function(text, x, y /*, maxWidth*/) {
      this._operations.push(["strokeText", text, false, false, false, x, y]);
    },

    fill: function() {
      this._operations.push(["fill"]);
    },

    stroke: function() {
      this._operations.push(["stroke"]);
    },

    measureText: function(text) {
      // TODO wire to native function
      return {width: text.length * 5 + 5};
    },

    _init: function(width, height) {
      this.canvas.width = width;
      this.canvas.height = height;
      this._gc._nativeCall("init", {
        width: width,
        height: height,
        font: [["sans-serif"], 12, false, false],
        fillStyle: [0, 0, 0, 255],
        strokeStyle: [0, 0, 0, 255]
      });
    },

    _flush: function() {
      if (this._operations.length > 0) {
        this._gc._nativeCall("draw", {operations: this._operations});
        this._operations = [];
      }
    }

  };

  var properties = {
    lineWidth: {
      init: 1,
      encode: function(value) {
        if (value > 0) {
          return value;
        }
        throw new Error(value);
      },
      decode: passThrough
    },
    lineCap: {
      init: "butt",
      values: toObject(["butt", "round", "square"]),
      encode: checkValue,
      decode: passThrough
    },
    lineJoin: {
      init: "miter",
      values: toObject(["bevel", "miter", "round"]),
      encode: checkValue,
      decode: passThrough
    },
    fillStyle: {
      init: [0, 0, 0, 255],
      encode: util.colorStringToArray,
      decode: util.colorArrayToString
    },
    strokeStyle: {
      init: [0, 0, 0, 255],
      encode: util.colorStringToArray,
      decode: util.colorArrayToString
    },
    textAlign: {
      init: "start",
      values: toObject(["start", "end", "left", "right", "center"]),
      encode: checkValue,
      decode: passThrough
    },
    textBaseline: {
      init: "alphabetic",
      values: toObject(["top", "hanging", "middle", "alphabetic", "ideographic", "bottom"]),
      encode: checkValue,
      decode: passThrough
    }
  };

  function passThrough(value) {
    return value;
  }

  function checkValue(value) {
    if (value in this.values) {
      return value;
    }
    throw new Error(value);
  }

  function toObject(array) {
    var obj = {};
    array.forEach(function(name) {
      obj[name] = true;
    });
    return obj;
  }

  function createState() {
    var state = {};
    for (var name in properties) {
      state[name] = properties[name].init;
    }
    return state;
  }

  function defineProperty(context, name) {
    var prop = properties[name];
    Object.defineProperty(context, name, {
      get: function() {
        return prop.decode(context._state[name]);
      },
      set: function(value) {
        try {
          context._state[name] = prop.encode(value);
          context._operations.push([name, this._state[name]]);
        } catch (error) {
          console.warn("Unsupported value for " + name + ": " + value);
        }
      }
    });
  }

})();

(function() {

  tabris.registerType("_ClientStore", {
    _type: "tabris.ClientStore"
  });

  var proxy;

  tabris.WebStorage = function() {
    proxy = tabris("_ClientStore");
  };

  tabris.WebStorage.prototype = {
    // Note: key and length methods currently not supported

    setItem: function(key, value) {
      if (!key) {
        throw new TypeError("Key argument must be specified to execute 'setItem'");
      }
      if (!value) {
        throw new TypeError("Value argument must be specified to execute 'setItem'");
      }
      if (typeof key === "string" && typeof value === "string") {
        proxy._nativeCall("add", {key: key, value: value});
      }
    },

    getItem: function(key) {
      // Note: the client implementation should return "null" when the item was not found
      if (typeof key === "string") {
        return proxy._nativeCall("get", {key: key});
      }
    },

    removeItem: function(key) {
      if (typeof key === "string") {
        proxy._nativeCall("remove", {keys: [key]});
      }
    },

    clear: function() {
      proxy._nativeCall("clear");
    }

  };

  tabris.StorageEvent = function(type) {
    this.type = type;
  };

  tabris.StorageEvent.prototype = util.extendPrototype(tabris.DOMEvent, {
    bubbles: false,
    cancelable: false,
    key: "",
    oldValue: null,
    newValue: null,
    url: "",
    storageArea: null
  });

  if (!window.Storage) {
    window.Storage = tabris.WebStorage;
    window.localStorage = new tabris.WebStorage();
  }

}());

// Created based on the W3C XMLHttpRequest specifications: http://www.w3.org/TR/XMLHttpRequest/
// References to sections listed on the same line as the the function definition.
// Append the section tag to the URL above to get the link to the corresponding section.
// Steps are referenced to with a number inside parentheses, e.g. (2)

(function() {

  tabris.registerType("_HttpRequest", {
    _type: "tabris.HttpRequest",
    _events: {StateChange: true, DownloadProgress: true, UploadProgress: true}
  });

  var eventTypes = [
    "loadstart", "readystatechange", "load", "loadend", "progress", "timeout", "abort", "error"
  ];
  var uploadEventTypes = ["progress", "loadstart", "load", "loadend", "timeout", "abort", "error"];

  // -----------------------------------------------------------------
  // Constructor

  tabris.XMLHttpRequest = function() {
    var scope = createScopeObject(this);
    definePropertyUpload(this, scope);
    definePropertyReadyState(this, scope);
    definePropertyTimeout(this, scope);
    definePropertyResponse(this, scope);
    definePropertyResponseText(this, scope);
    definePropertyResponseType(this, scope);
    definePropertyStatus(this, scope);
    definePropertyStatusText(this, scope);
    definePropertyWithCredentials(this, scope);
    defineEventHandlers(this, scope);
    initializeEventHandlers(scope);
    this.open = createOpenMethod(this, scope);
    this.send = createSendMethod(this, scope);
    this.abort = createAbortMethod(this, scope);
    this.setRequestHeader = createSetRequestHeaderMethod(this, scope);
    this.getResponseHeader = createGetResponseHeaderMethod(this, scope);
    this.getAllResponseHeaders = createGetAllResponseHeadersMethod(this, scope);
    tabris._addDOMEventTargetMethods(this);
    tabris._addDOMEventTargetMethods(scope.uploadEventTarget);
  };

  tabris.XMLHttpRequest.prototype = {
    UNSENT: 0,
    OPENED: 1,
    HEADERS_RECEIVED: 2,
    LOADING: 3,
    DONE: 4
  };

  // -----------------------------------------------------------------
  // Events

  tabris.XMLHttpRequestProgressEvent = function(type) {
    this.type = type;
  };

  tabris.XMLHttpRequestProgressEvent.prototype = util.extendPrototype(tabris.DOMEvent, {
    lengthComputable: false,
    loaded: 0,
    total: 0
  });

  // -----------------------------------------------------------------
  // Properties

  var createScopeObject = function(xhr) {
    var scope = {};
    scope.proxy = null;
    scope.authorRequestHeaders = {};
    scope.uploadListeners = {};
    scope.uploadEventTarget = {};
    scope.timeout = 0;
    scope.status = 0;
    scope.statusText = "";
    scope.responseHeaders = "";
    scope.readyState = xhr.UNSENT;
    scope.responseText = "";
    scope.withCredentials = false;
    scope.responseType = "";
    scope.sendInvoked = false;
    scope.isSynchronous = false;
    scope.error = false;
    scope.uploadComplete = false;
    return scope;
  };

  var initializeEventHandlers = function(scope) {
    eventTypes.forEach(function(eventType) {
      scope["on" + eventType] = null;
    });
    uploadEventTypes.forEach(function(eventType) {
      scope.uploadListeners["on" + eventType] = null;
    });
  };

  var definePropertyUpload = function(xhr, scope) {
    Object.defineProperty(xhr, "upload", {
      get: function() {
        return scope.uploadEventTarget;
      },
      set: function() {}
    });
  };

  var definePropertyReadyState = function(xhr, scope) {
    Object.defineProperty(xhr, "readyState", {
      get: function() {
        return scope.readyState;
      },
      set: function() {}
    });
  };

  var definePropertyTimeout = function(xhr, scope) {
    Object.defineProperty(xhr, "timeout", { // #the-timeout-attribute
      get: function() {
        return scope.timeout;
      },
      set: function(value) {
        // (1): superfluous, as we don't support synchronous requests
        if (!isNaN(value)) { // (2)
          scope.timeout = Math.round(value);
        }
      }
    });
  };

  var definePropertyResponseText = function(xhr, scope) {
    Object.defineProperty(xhr, "responseText", { // #dom-xmlhttprequest-responsetext
      get: function() {
        // Steps merged with #text-response-entity-body, entity body steps marked with '*'
        // Note: HttpRequest's response is already stringified
        if (scope.responseText === null) { // (1*)
          return "";
        }
        if (typeof scope.responseText !== "string") { // (1*)
          throw new Error("IllegalStateError: responseText is not a string");
        }
        if ((scope.readyState !== xhr.LOADING && scope.readyState !== xhr.DONE)) { // (2)
          return "";
        }
        if (scope.error) { // (3)
          return "";
        }
        return scope.responseText;
      },
      set: function() {}
    });
  };

  var definePropertyResponse = function(xhr, scope) {
    Object.defineProperty(xhr, "response", { // #dom-xmlhttprequest-responsetext
      get: function() {
        // Note: only the if-statement implemented, as response types different than 'text' are
        // currently not supported
        if (scope.readyState !== xhr.LOADING && scope.readyState !== xhr.DONE) { // (1)
          return "";
        }
        if (scope.error) { // (2)
          return "";
        }
        return scope.responseText; // (3)
      },
      set: function() {}
    });
  };

  var definePropertyResponseType = function(xhr, scope) {
    Object.defineProperty(xhr, "responseType", { // #dom-xmlhttprequest-responsetype
      get: function() {
        return scope.responseType;
      },
      set: function(value) {
        if ((scope.readyState === xhr.LOADING || scope.readyState === xhr.DONE)) { // (1)
          throw new Error(
              "InvalidStateError: state must not be 'LOADING' or 'DONE' when setting responseType"
          );
        }
        // (2): superfluous as we don't support synchronous requests
        // (3): we don't handle the concurrency in this layer, so no worker environments
        // mimicking Chromium and Firefox behaviour when setting a not allowed responseType:
        if (["arraybuffer", "blob", "document", "json", "text"].indexOf(value) < 0) {
          return;
        }
        // currently only the 'text' response type is supported
        if (["arraybuffer", "blob", "document", "json"].indexOf(value) > -1) {
          throw new Error("Only the 'text' response type is supported.");
        }
        scope.responseType = value;
      }
    });
  };

  var defineEventHandlers = function(xhr, scope) {
    eventTypes.forEach(function(eventType) {
      defineEventHandler(eventType, xhr, scope);
    });
    uploadEventTypes.forEach(function(eventType) {
      defineEventHandler(eventType, scope.uploadEventTarget, scope.uploadListeners);
    });
  };

  var defineEventHandler = function(eventType, target, listeners) {
    var handler = "on" + eventType;
    Object.defineProperty(target, handler, {
      get: function() {
        return listeners[handler];
      },
      set: function(value) {
        // mimicks the behavior of Firefox and Chromium
        if (typeof value === "function") {
          target.removeEventListener(eventType, target[handler]);
          listeners[handler] = value;
          target.addEventListener(eventType, target[handler]);
        }
      }
    });
  };

  var definePropertyStatus = function(xhr, scope) {
    Object.defineProperty(xhr, "status", { // #the-status-attribute
      get: function() {
        if ([xhr.OPENED, xhr.UNSENT].indexOf(scope.readyState) > -1) { // (1)
          return 0;
        }
        if (scope.error) { // (2)
          return 0;
        }
        return scope.status; // (3)
      },
      set: function() {}
    });
  };

  var definePropertyStatusText = function(xhr, scope) {
    Object.defineProperty(xhr, "statusText", {
      get: function() { // #the-statustext-attribute
        if ([xhr.OPENED, xhr.UNSENT].indexOf(scope.readyState) > -1) { // (1)
          return "";
        }
        if (scope.error) { // (2)
          return "";
        }
        return scope.statusText; // (3)
      },
      set: function() {}
    });
  };

  var definePropertyWithCredentials = function(xhr, scope) {
    Object.defineProperty(xhr, "withCredentials", { // #the-withcredentials-attribute
      set: function(value) {
        if (scope.readyState !== xhr.UNSENT && scope.readyState !== xhr.OPENED) { // (1)
          throw new Error(
              "InvalidStateError: state must be 'UNSENT' or 'OPENED' when setting withCredentials"
          );
        }
        if (scope.sendInvoked) { // (2)
          throw new Error("InvalidStateError: 'send' invoked, failed to set 'withCredentials'");
        }
        // (3): superfluous as we don't support synchronous requests
        // mimicking Chromium and Firefox behaviour when setting a non-boolean value:
        if (typeof value === "boolean") {
          scope.withCredentials = value; // (4)
        }
      },
      get: function() {
        return scope.withCredentials;
      }
    });
  };

  // -----------------------------------------------------------------
  // Methods

  var createOpenMethod = function(xhr, scope) {
    return function(method, url, async, username, password) { // #dom-xmlhttprequest-open
      var parsedUrl = {};
      // (2), (3), (4): we don't implement the 'settings' object
      validateRequiredOpenArgs(method, url);
      parsedUrl.source = url; // (8), (9): experimental non-standard parsing implementation:
      // regex taken from http://stackoverflow.com/a/8206299:
      var urlWithoutProtocol = url.replace(/.*?:\/\//g, "");
      // regex taken from http://stackoverflow.com/a/19709846:
      parsedUrl.isRelative = !new RegExp("^(?:[a-z]+:)?//", "i").test(url);
      parsedUrl.userdata = urlWithoutProtocol.substring(0, urlWithoutProtocol.indexOf("@"));
      if (typeof async === "undefined") { // (10)
        async = true;
        username = null;
        password = null;
      }
      if (!async) {
        throw new Error("Only asynchronous request supported.");
      }
      if (parsedUrl.isRelative) { // (11)
        if (username && password) {
          parsedUrl.userdata = username + ":" + password;
        }
      }
      // (12): superfluous as we don't support synchronous requests
      // TODO: (13) - should we call 'abort' to the proxy? We'd need to move the creation of the proxy
      // to the open() function
      scope.requestMethod = method; // (14)
      scope.requestUrl = parsedUrl;
      scope.isSynchronous = !async;
      scope.authorRequestHeaders = {};
      scope.sendInvoked = false;
      scope.responseText = null;
      if (scope.readyState !== xhr.OPENED) { // (15)
        scope.readyState = xhr.OPENED;
        dispatchXHREvent("readystatechange", xhr);
      }
    };
  };

  var createSendMethod = function(xhr, scope) {
    return function(data) { // #the-send()-method
      scope.proxy = tabris.create("_HttpRequest");
      scope.proxy.on("StateChange", function(e) {
        stateChangeHandler(e, xhr, scope);
      });
      scope.proxy.on("DownloadProgress", function(e) {
        dispatchProgressEvent("progress", xhr, e.lengthComputable, e.loaded, e.total);
      });
      scope.proxy.on("UploadProgress", function(e) {
        dispatchProgressEvent("progress", xhr.upload, e.lengthComputable, e.loaded, e.total);
      });
      if (scope.readyState !== xhr.OPENED) { // (1)
        throw new Error(
            "InvalidStateError: Object's state must be 'OPENED', failed to execute 'send'"
        );
      }
      if (scope.sendInvoked) { // (2)
        throw new Error("InvalidStateError: 'send' invoked, failed to execute 'send'");
      }
      if (["GET", "HEAD"].indexOf(scope.requestMethod) > -1) { // (3)
        data = null;
      }
      scope.requestBody = data; // (4)
      // TODO: support encoding and mimetype for string response types
      // (5): no storage mutex
      scope.error = scope.uploadComplete = false; // (6), see (8)
      if (!data) { // (7)
        scope.uploadComplete = true;
      }
      // (8): uploadEvents is relevant for the "force preflight flag", but this logic is handled by
      // the client
      // Basic access authentication
      if (scope.withCredentials) {
        // TODO: encode userdata in base64, will not function if not encoded
        if (scope.requestUrl.userdata) {
          xhr.setRequestHeader("Authorization", "Basic " + scope.requestUrl.userdata);
        }
      }
      scope.sendInvoked = true; // (9.1)
      dispatchProgressEvent("loadstart", xhr); // (9.2)
      if (!scope.uploadComplete) {
        dispatchProgressEvent("loadstart", xhr.upload); // (9.3)
      }
      // (10): only handling the same origin case
      scope.proxy._nativeCall("send", { // request URL fetch
        url: scope.requestUrl.source,
        method: scope.requestMethod,
        timeout: xhr.timeout,
        headers: scope.authorRequestHeaders,
        data: scope.requestBody
      });
    };
  };

  var createAbortMethod = function(xhr, scope) {
    return function() { // #the-abort()-method
      if (scope.proxy) {
        scope.proxy._nativeCall("abort"); // (1)
      }
      if (!([xhr.UNSENT, xhr.OPENED].indexOf(scope.readyState) > -1 && !scope.sendInvoked ||
          scope.readyState === xhr.DONE)) { // send() interrupted
        // (2.1), (2.2): setting readyState DONE with sendInvoked true or false seems to be an
        // internal state which doesn't affect the behavior and thus cannot be tested
        dispatchXHREvent("readystatechange", xhr); // (2.3)
        if (!scope.uploadComplete) {
          scope.uploadComplete = true; // (2.4.1)
          dispatchAbortProgressEvents(xhr.upload); // (2.4.2), (2.4.3), (2.4.4)
        }
        dispatchAbortProgressEvents(xhr); // (2.5), (2.6), (2.7)
      }
      scope.readyState = xhr.UNSENT; // (3)
    };
  };

  var createSetRequestHeaderMethod = function(xhr, scope) {
    return function(header, value) { // #dom-xmlhttprequest-setrequestheader
      if (scope.readyState !== xhr.OPENED) { // (1)
        throw new Error("InvalidStateError: " +
                "Object's state must be 'OPENED', failed to execute 'setRequestHeader'");
      }
      if (scope.sendInvoked) { // (2)
        throw new Error("InvalidStateError: " +
                "cannot set request header if 'send()' invoked and request not completed");
      }
      if (!validHttpToken(header)) { // (3)
        throw new TypeError("Invalid HTTP header name, failed to execute 'open'");
      }
      if (!isValidHttpHeaderValue(value)) { // (4)
        throw new TypeError("Invalid HTTP header value, failed to execute 'open'");
      }
      if (isForbiddenHeader(header)) { // (5)
        throw new Error("Cannot set forbidden header '" + header + "'");
      }
      if (header in scope.authorRequestHeaders) { // (6):
        scope.authorRequestHeaders[header] = scope.authorRequestHeaders[header] + ", " + value; // (7)
      } else {
        scope.authorRequestHeaders[header] = value; // (8)
      }
    };
  };

  var createGetResponseHeaderMethod = function(xhr, scope) {
    return function(header) { // #the-getresponseheader()-method
      if ([xhr.UNSENT, xhr.OPENED].indexOf(xhr.readyState) > -1) { // (1)
        return null;
      }
      if (scope.error) { // (2)
        return null;
      }
      var forbiddenHeaders = ["set-cookie", "set-cookie2", "status"]; // (3)
      if (forbiddenHeaders.indexOf(header.toLowerCase()) > -1) {
        return null;
      }
      for (var key in scope.responseHeaders) { // (4), (5)
        if (key.toLowerCase() === header.toLowerCase()) {
          return scope.responseHeaders[key];
        }
      }
      return null; // (6)
    };
  };

  var createGetAllResponseHeadersMethod = function(xhr, scope) {
    return function() { // #the-getallresponseheaders()-method
      if ([xhr.UNSENT, xhr.OPENED].indexOf(xhr.readyState) > -1) { // (1)
        return "";
      }
      if (scope.error) { // (2)
        return "";
      }
      return stringifyResponseHeaders(scope.responseHeaders); // (3)
    };
  };

  var stringifyResponseHeaders = function(headers) {
    var string = [];
    var forbiddenHeaders = ["set-cookie", "set-cookie2", "status"];
    for (var key in headers) {
      if (forbiddenHeaders.indexOf(key.toLowerCase()) < 0) {
        string.push(key + ": " + headers[key]);
      }
    }
    return string.join("\n");
  };

  // -----------------------------------------------------------------
  // Event handler

  var stateChangeHandler = function(e, xhr, scope) { // #infrastructure-for-the-send()-method
    // Note: we supply lengthComputable, loaded and total only with the "progress" event types
    switch (e.state) {
      case "headers":
        scope.readyState = xhr.HEADERS_RECEIVED;
        scope.status = e.code;
        scope.statusText = e.message;
        scope.responseHeaders = e.headers;
        dispatchXHREvent("readystatechange", xhr);
        scope.uploadComplete = true; // #make-upload-progress-notifications
        dispatchFinishedProgressEvents(xhr.upload);
        break;
      case "loading":
        scope.readyState = xhr.LOADING;
        dispatchXHREvent("readystatechange", xhr);
        break;
      case "finished":
        // TODO create response based on responseType
        scope.responseText = e.response;
        scope.readyState = xhr.DONE;
        dispatchXHREvent("readystatechange", xhr);
        dispatchFinishedProgressEvents(xhr);
        dispatchFinishedProgressEvents(xhr.upload);
        scope.proxy.dispose();
        scope.proxy = null;
        break;
      case "error":
        handleRequestError("error", xhr, scope);
        break;
      case "timeout":
        handleRequestError("timeout", xhr, scope);
        break;
      case "abort":
        handleRequestError("abort", xhr, scope);
        break;
    }
  };

  var handleRequestError = function(event, xhr, scope) { // #request-error
    scope.error = true; // (1*) (#terminate-the-request)
    scope.readyState = xhr.DONE; // (1)
    // (2): superfluous as we don't support synchronous requests
    dispatchXHREvent("readystatechange", xhr); // (3)
    dispatchErrorProgressEvents(event, xhr);
    if (!scope.uploadComplete) {
      scope.uploadComplete = true;
      dispatchErrorProgressEvents(event, xhr.upload);
    }
    scope.proxy.dispose();
    scope.proxy = null;
  };

  // -----------------------------------------------------------------
  // Validators

  var validateRequiredOpenArgs = function(method, url) {
    if (!method) {
      throw new TypeError("Method argument should be specified to execute 'open'");
    }
    if (!url) {
      throw new TypeError("URL argument should be specified to execute 'open'");
    }
    validateMethod(method);
    // TODO: URL validation commented out as Rhino crashes with an OOM-error with several URLs
    // validateUrl(url);
  };

  var validateMethod = function(method) {
    if (!validHttpToken(method)) {
      throw new TypeError("Invalid HTTP method, failed to execute 'open'");
    }
    // (6):
    var tokens = ["CONNECT", "DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT", "TRACE", "TRACK"];
    var uppercaseMethod = method.toUpperCase();
    if (tokens.indexOf(uppercaseMethod) >= 0) {
      method = uppercaseMethod;
    }
    var forbiddenTokens = ["CONNECT", "TRACE", "TRACK"]; // (7)
    if (forbiddenTokens.indexOf(method) >= 0) {
      throw new Error(
              "SecurityError: '" + method + "' HTTP method is not secure, failed to execute 'open'"
      );
    }
  };

  var validHttpToken = function(httpToken) {
    // RFC-compliant validation for HTTP tokens ported from Chromium:
    // https://chromium.googlesource.com/chromium/blink.git/+/master/Source/platform/network/HTTPParsers.cpp
    var forbiddenCharacters = ["(", ")", "<", ">", "@", ",", ";", ":", "\\", "\"", "\/", "[", "]",
        "?", "=", "{", "}"];
    return !(/[^\x21-\x7E]/.test(httpToken) || forbiddenCharacters.indexOf(httpToken) >= 0);
  };

  var isValidHttpHeaderValue = function(value) {
    // non-RFC compliant validation for HTTP header values ported from Chromium:
    // https://chromium.googlesource.com/chromium/blink.git/+/master/Source/platform/network/HTTPParsers.cpp
    // Regex for Latin-1 characters only: https://gist.github.com/LeoDutra/3044325
    return !(!(/[*A-z\u00C0-\u00ff]+/g).test(value) || value.indexOf("\n") > -1 ||
        value.indexOf("\r") > -1);
  };

  var isForbiddenHeader = function(header) {
    return forbiddenHeaders.indexOf(header.toLowerCase()) > -1;
  };

  // URL validation commented out as Rhino crashes with an OOM-error with several URLs
  // var validateUrl = function(url) {
  //   // TODO: rewrite (8),(9)
  //   // taken from https://gist.github.com/dperini/729294
  //   if(!urlValidationRegex.test(url)){
  //     throw new SyntaxError("Malformed URI, failed to execute 'open'");
  //   }
  // };

  var forbiddenHeaders = [
    "accept-charset",
    "accept-encoding",
    "access-control-request-headers",
    "access-control-request-method",
    "connection",
    "content-length",
    "cookie",
    "date",
    "dnt",
    "expect",
    "host",
    "keep-alive",
    "origin",
    "referer",
    "te",
    "trailer",
    "transfer-encoding",
    "upgrade",
    "user-agent",
    "via"
  ];

  // URL validation commented out as Rhino crashes with an OOM-error with several URLs
  // Taken from https://gist.github.com/dperini/729294
  // TODO: add to copyright header
  // var urlValidationRegex = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!(?:10|127)(?:\.\d{1,3}){3})(?!(?:169\.254|192\.168)(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:[a-z\u00a1-\uffff]{2,})))(?::\d{2,5})?(?:\/\S*)?$/i;

  // -----------------------------------------------------------------
  // Event dispatcher

  var dispatchProgressEvent = function(type, target, lengthComputable, loaded, total) {
    target.dispatchEvent(initXhrProgressEvent(type, target, lengthComputable, loaded, total));
  };

  var dispatchAbortProgressEvents = function(context) {
    dispatchProgressEvent("progress", context);
    dispatchProgressEvent("abort", context);
    dispatchProgressEvent("loadend", context);
  };

  var dispatchErrorProgressEvents = function(event, context) {
    dispatchProgressEvent("progress", context);
    dispatchProgressEvent(event, context);
    dispatchProgressEvent("loadend", context);
  };

  var dispatchFinishedProgressEvents = function(context) {
    // Note: progress event is dispatched separately by the DownloadProgress/UploadProgress callbacks
    dispatchProgressEvent("load", context);
    dispatchProgressEvent("loadend", context);
  };

  var initXhrProgressEvent = function(type, target, lengthComputable, loaded, total) {
    var xhrProgressEvent = new tabris.XMLHttpRequestProgressEvent(type);
    xhrProgressEvent.currentTarget = xhrProgressEvent.target = target;
    if (lengthComputable) {
      xhrProgressEvent.lengthComputable = lengthComputable;
    }
    if (loaded) {
      xhrProgressEvent.loaded = loaded;
    }
    if (total) {
      xhrProgressEvent.total = total;
    }
    return xhrProgressEvent;
  };

  var dispatchXHREvent = function(type, target) {
    var xhrEvent = initXhrEvent(type, target);
    target.dispatchEvent(xhrEvent);
  };

  var initXhrEvent = function(type, target) {
    var xhrEvent = new tabris.DOMEvent(type);
    xhrEvent.currentTarget = xhrEvent.target = target;
    return xhrEvent;
  };

  // -----------------------------------------------------------------
  // Export

  if (typeof XMLHttpRequest === "undefined") {
    window.XMLHttpRequest = tabris.XMLHttpRequest;
    window.XMLHttpRequestProgressEvent = tabris.XMLHttpRequestProgressEvent;
  }

})();

}());